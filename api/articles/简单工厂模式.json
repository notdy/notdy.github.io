{"title":"简单工厂模式","uid":"8ba451d9968003045919daef83bc7892","slug":"简单工厂模式","date":"2023-12-04T09:06:01.000Z","updated":"2023-12-11T08:30:40.212Z","comments":true,"path":"api/articles/简单工厂模式.json","keywords":null,"cover":[],"content":"<blockquote>\n<p>这个系列主要是记录我看大话设计模式这一本书的一些感受，会有部分图片是来自于《大话设计模式》这本书</p>\n</blockquote>\n<p>设计一个计算器,以java为例</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><h1 id=\"第一个版本\"><a href=\"#第一个版本\" class=\"headerlink\" title=\"第一个版本\"></a>第一个版本</h1><p>不费吹灰之力，轻松拿下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.Scanner;\n\nclass Study&#123;\n    public static void main(String[] args) &#123;\n        Scanner s &#x3D; new Scanner(System.in);\n        System.out.print(&quot;请输入数字A:&quot;);\n        double numsA &#x3D; s.nextDouble();\n        System.out.print(&quot;请输入运算符号:&quot;);\n        String operator &#x3D; s.next().strip();\n        System.out.print(&quot;请输入数字B:&quot;);\n        double numsB &#x3D; s.nextDouble();\n        System.out.println(calculate(numsA,numsB,operator));\n        s.close();\n    &#125;\n    public static String calculate(double a,double b,String operator)&#123;\n        StringBuilder sb &#x3D; new StringBuilder();\n        switch (operator)&#123;\n            case &quot;+&quot;:\n                sb.append(String.format(&quot;%.1f + %.1f &#x3D; %.1f&quot;,a,b,a+b));\n                break;\n            case &quot;-&quot;:\n                sb.append(String.format(&quot;%.1f - %.1f &#x3D; %.1f&quot;,a,b,a-b));\n                break;\n            case &quot;*&quot;:\n                sb.append(String.format(&quot;%.1f * %.1f &#x3D; %.1f&quot;,a,b,a*b));\n                break;\n            case &quot;&#x2F;&quot;:\n                sb.append(String.format(&quot;%.1f &#x2F; %.1f &#x3D; %.11f&quot;,a,b,a&#x2F;b));\n                break;\n            default:\n                return &quot;运算符不支持或错误&quot;;\n        &#125;\n        return sb.toString();\n    &#125;\n&#125;</code></pre>\n<h2 id=\"不足之处\"><a href=\"#不足之处\" class=\"headerlink\" title=\"不足之处\"></a>不足之处</h2><ol>\n<li>运算符这一参数特别可能输错,用户怎么知道你支持哪些运算符?</li>\n<li>对于异常没有处理,如除以0的异常没有处理</li>\n</ol>\n<h1 id=\"第二个版本\"><a href=\"#第二个版本\" class=\"headerlink\" title=\"第二个版本\"></a>第二个版本</h1><p>加异常处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.Scanner;\n\nclass Study&#123;\n    public static void main(String[] args) &#123;\n        Scanner s &#x3D; new Scanner(System.in);\n        System.out.print(&quot;请输入数字A:&quot;);\n        double numsA &#x3D; s.nextDouble();\n        System.out.print(&quot;请输入运算符号(+ - * &#x2F;):&quot;); &#x2F;&#x2F;这里用图形化界面可能更好点\n        String operator &#x3D; s.next().strip();\n        while(isOperator(operator))&#123;\n            System.out.print(&quot;不正确，重新输入:&quot;)\n            opertaor &#x3D; s.next().strip();    \n        &#125;\n        System.out.print(&quot;请输入数字B:&quot;);\n        double numsB &#x3D; s.nextDouble();\n        System.out.println(calculate(numsA,numsB,operator));\n        s.close();\n    &#125;\n    public static boolean isOperator(String s)&#123;\n        switch(s)&#123;\n            case &quot;+&quot;:\n            case &quot;-&quot;:\n            case &quot;*&quot;:\n            case &quot;&#x2F;&quot;:\n                return true;\n        &#125;\n        return false;\n    &#125;\n    public static String calculate(double a,double b,String operator)&#123;\n        StringBuilder sb &#x3D; new StringBuilder();\n        switch (operator)&#123;\n            case &quot;+&quot;:\n                sb.append(String.format(&quot;%.1f + %.1f &#x3D; %.1f&quot;,a,b,a+b));\n                break;\n            case &quot;-&quot;:\n                sb.append(String.format(&quot;%.1f - %.1f &#x3D; %.1f&quot;,a,b,a-b));\n                break;\n            case &quot;*&quot;:\n                sb.append(String.format(&quot;%.1f * %.1f &#x3D; %.1f&quot;,a,b,a*b));\n                break;\n            case &quot;&#x2F;&quot;:\n                if(b&#x3D;&#x3D;0)\n                    return &quot;不能除0&quot;;\n                sb.append(String.format(&quot;%.1f &#x2F; %.1f &#x3D; %.11f&quot;,a,b,a&#x2F;b));\n                break;\n            default:\n                return &quot;运算符不支持或错误&quot;;\n        &#125;\n        return sb.toString();\n    &#125;\n&#125;</code></pre>\n<h2 id=\"第三个版本\"><a href=\"#第三个版本\" class=\"headerlink\" title=\"第三个版本\"></a>第三个版本</h2><h3 id=\"一些感悟\"><a href=\"#一些感悟\" class=\"headerlink\" title=\"一些感悟\"></a>一些感悟</h3><p>以下感受是结合活字印刷的</p>\n<ul>\n<li>可维护性:只用改想改的地方，不用改不想改的地方，或者说只用改局部，不用改整体。比如文章局部不好，只需要对局部进行修改，而不用改整体</li>\n<li>可复用性:按功能点划分，形成一个组件，这样可以在以后的业务中能反复使用，公司里好像叫组件库或者构件库。我的理解就是一个字不可能只用一次，常用的字在文章中有大量的使用</li>\n<li>可扩展性: 加功能点很容易。结合活字印刷来说就是添加文字特别简单</li>\n<li>灵活性好:通过简易的操作来实现一些简单的功能。</li>\n</ul>\n<p>设计过程:在整个过程中，只有运算的数在改变，运算规则不变，将运算规则抽取出来（作为一个类operator，+-*&#x2F;都继承operator即可），运算的数字作为参数传递过去。</p>\n<p>Operator类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nabstract class Operator&#123;\n    public Double getA() &#123;\n        return a;\n    &#125;\n\n    public void setA(Double a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public Double getB() &#123;\n        return b;\n    &#125;\n\n    public void setB(Double b) &#123;\n        this.b &#x3D; b;\n    &#125;\n\n    private Double a,b;\n    public Operator(Double a,Double b)&#123;\n        this.a &#x3D; a;\n        this.b &#x3D; b;\n    &#125;\n    public Operator()&#123;\n\n    &#125;\n    public abstract double getResult();\n&#125;\n&#125;</code></pre>\n\n<p>加减乘除类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Add extends Operator&#123;\n\n\n    @Override\n    public double getResult() &#123;\n        return getA()+getB();\n    &#125;\n&#125;\nclass Sub extends Operator&#123;\n    @Override\n    public double getResult() &#123;\n        return getA() - getB();\n    &#125;\n&#125;\nclass Mul extends Operator&#123;\n    @Override\n    public double getResult() &#123;\n        return getA()*getB();\n    &#125;\n&#125;\nclass Div extends Operator&#123;\n\n\n    @Override\n    public double getResult()throws ArithmeticException &#123;\n        double res &#x3D; 0;\n        if(getB()&#x3D;&#x3D;0)\n            throw new ArithmeticException(&quot;除数为0&quot;);\n        else res &#x3D; getA()&#x2F;getB();\n        return res;\n    &#125;\n&#125;</code></pre>\n<p>工厂类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class OperatorFactory&#123;\n    public static Operator GenerateOperatorByCharacter(String s)&#123;\n        Operator res &#x3D; null;\n        switch (s)&#123;\n            case &quot;+&quot;:\n                res &#x3D; new Add();\n                break;\n            case &quot;-&quot;:\n                res &#x3D; new Sub();\n                break;\n            case &quot;*&quot;:\n                res &#x3D; new Mul();\n                break;\n            case &quot;&#x2F;&quot;:\n                res &#x3D; new Div();\n                break;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p>主程序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Scanner s &#x3D; new Scanner(System.in);\n    System.out.print(&quot;请输入数字A:&quot;);\n    double numsA &#x3D; s.nextDouble();\n    System.out.print(&quot;请输入运算符号:&quot;);\n    String operator &#x3D; s.next().strip();\n    System.out.print(&quot;请输入数字B:&quot;);\n    double numsB &#x3D; s.nextDouble();\n    Operator operator1 &#x3D; OperatorFactory.GenerateOperatorByCharacter(operator);\n    operator1.setA(numsA);\n    operator1.setB(numsB);\n    System.out.println(operator1.getResult());\n    s.close();\n&#125;</code></pre>\n<p>这样一来若加入其他运算只用加类，在工厂方法中加入代码即可</p>\n<h1 id=\"UML类图\"><a href=\"#UML类图\" class=\"headerlink\" title=\"UML类图\"></a>UML类图</h1><p>这个多看看就行，来看一个比较全的图<br><img src=\"/../images/Snipaste_2023-12-11_15-30-40.jpg\" alt=\"UML类图全\"></p>\n<p>在UML中+-#的含义如下</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>表示的修饰符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>public</td>\n</tr>\n<tr>\n<td>-</td>\n<td>private</td>\n</tr>\n<tr>\n<td>#</td>\n<td>protected</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>在UML图中‘+’表示public,’-‘表示private,’#’表示protected</p>\n</blockquote>\n<h2 id=\"类的表示\"><a href=\"#类的表示\" class=\"headerlink\" title=\"类的表示\"></a>类的表示</h2><p>从动物这个类开始解析<br><img src=\"/../images/animal%20resolve.jpg\" alt=\"解析动物类\"><br><b>一个矩形框就是一个类，第一层就是类名，如果是抽象类，类名须用斜体，第二层是属性和字段，第三层是方法或行为。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>表示:虚线的实心箭头<br>我的个人理解就是在B中用到了A，那么B就依赖于A，B受制于A。<br><img src=\"/../images/resolveDependency.jpg\"><br>想起了一张图片：燕子，没有你我可怎么活啊<br><img src=\"/../images/explainDependency.gif\"></p>\n<h2 id=\"接口的表示\"><a href=\"#接口的表示\" class=\"headerlink\" title=\"接口的表示\"></a>接口的表示</h2><p>和类表示的不同之处主要在于其顶端有《interface》，第一行是接口名称；第二行是接口方法；<br><img src=\"/../images/interface.jpg\"><br>还有一种方式来表示接口,以下面的图为例，应该是唐老鸭实现了讲人话的接口<br><img src=\"/../images/ExpressInterfaceTwo.jpg\"></p>\n<h2 id=\"继承类和实现接口的表示\"><a href=\"#继承类和实现接口的表示\" class=\"headerlink\" title=\"继承类和实现接口的表示\"></a>继承类和实现接口的表示</h2><p>实现接口是用空心三角形+虚线来表示.例如:<br><img src=\"/../images/inherit.jpg\"><br>继承使用空心三角形+实线来表示<br><img src=\"/../images/implementaInterface.jpg\"></p>\n<h2 id=\"关联的表示\"><a href=\"#关联的表示\" class=\"headerlink\" title=\"关联的表示\"></a>关联的表示</h2><p>表示：用实现箭头来表示<br><img src=\"/../images/association.jpg\"><br>此书中表示：当一个类“知道”另一个类时，可以用关联。但是让我不理解的是什么叫做知道？</p>\n<h2 id=\"聚合的表示\"><a href=\"#聚合的表示\" class=\"headerlink\" title=\"聚合的表示\"></a>聚合的表示</h2><p>用空心的菱形+实现箭头来表示<br><img src=\"/../images/aggregation.jpg\"><br>表示一种<b>弱</b>的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p>\n<blockquote>\n<p>弱的体现<br>个体离开了群体还能存活</p>\n</blockquote>\n<h2 id=\"组合的表示\"><a href=\"#组合的表示\" class=\"headerlink\" title=\"组合的表示\"></a>组合的表示</h2><p>用<b>实心的菱形+实现箭头</b>来表示<br><img src=\"/../images/Composition.jpg\"><br>其表示一种<b>强</b>的拥有关系，说人话就是群体离开了个体，这个群体就废了.以图片为例，鸟没了翅膀不就废了吗<br>图片上的1和2是表示基数<br>2：表示1只鸟有两个翅膀<br>1：表示两个翅膀对应一只鸟</p>\n<h2 id=\"总结篇\"><a href=\"#总结篇\" class=\"headerlink\" title=\"总结篇\"></a>总结篇</h2><p>这里只总结容易混的东西</p>\n<table>\n<thead>\n<tr>\n<th>关系</th>\n<th>表示</th>\n<th>技巧</th>\n<th>指向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>继承</td>\n<td>实线空心三角形</td>\n<td>继承的都是具体的东西，用实线</td>\n<td>从子类指向父类</td>\n</tr>\n<tr>\n<td>实现接口</td>\n<td>虚线空心三角形</td>\n<td>实现的是相较于比较虚的，用虚线</td>\n<td>从类指向接口</td>\n</tr>\n<tr>\n<td>组合</td>\n<td>实心菱形+实线箭头</td>\n<td>，由于比较强（内心丰盈）所以是实心</td>\n<td>部分指向整体</td>\n</tr>\n<tr>\n<td>聚合</td>\n<td>空心的菱形+实线箭头</td>\n<td>约束性不强，空心</td>\n<td>部分指向整体</td>\n</tr>\n</tbody></table>\n","feature":true,"text":" 这个系列主要是记录我看大话设计模式这一本书的一些感受，会有部分图片是来自于《大话设计模式》这本书 设计一个计算器,以java为例 需求第一个版本不费吹灰之力，...","permalink":"/post/简单工厂模式","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82\"><span class=\"toc-text\">需求</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">第一个版本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84\"><span class=\"toc-text\">不足之处</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">第二个版本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">第三个版本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F\"><span class=\"toc-text\">一些感悟</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UML%E7%B1%BB%E5%9B%BE\"><span class=\"toc-text\">UML类图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">类的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">接口的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">继承类和实现接口的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">关联的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%81%9A%E5%90%88%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">聚合的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">组合的表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%E7%AF%87\"><span class=\"toc-text\">总结篇</span></a></li></ol>","author":{"name":"矽","slug":"blog-author","avatar":"https://ik.imagekit.io/bennyxguo/ObsidianestLogo-hex_hecqbw.png?updatedAt=1692679397324","link":"/","description":"","socials":{"github":"https://github.com/notdy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45418837","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibli.jpg","link":"https://space.bilibili.com/441747654"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"SpringWeb踩坑记录","uid":"beb0574b5617d16378226a82c445c69b","slug":"SpringWeb踩坑记录","date":"2023-11-10T12:38:27.000Z","updated":"2023-11-10T12:45:08.566Z","comments":true,"path":"api/articles/SpringWeb踩坑记录.json","keywords":null,"cover":[],"text":"解决Maven依赖下载奇慢的问题,服务器在国外，很慢的在IDEA中按两次shift键，输入settings.xml,选择Create粘贴以下内容到文件中 &lt...","permalink":"/post/SpringWeb踩坑记录","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"}],"author":{"name":"矽","slug":"blog-author","avatar":"https://ik.imagekit.io/bennyxguo/ObsidianestLogo-hex_hecqbw.png?updatedAt=1692679397324","link":"/","description":"","socials":{"github":"https://github.com/notdy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45418837","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibli.jpg","link":"https://space.bilibili.com/441747654"}}}},"feature":true}}