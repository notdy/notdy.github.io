{"title":"策略模式","uid":"8ced7c3b7dad33d06ee59bde7028cd4a","slug":"策略模式","date":"2023-12-12T07:19:40.000Z","updated":"2023-12-12T09:28:36.139Z","comments":true,"path":"api/articles/策略模式.json","keywords":null,"cover":[],"content":"<blockquote>\n<p>是记录看《大话设计模式》这本书的感受</p>\n</blockquote>\n<p>还是从一个想法开始入手，书中的是让我们写一个商场收银系统，由于我java没有学GUI的那部分，我就直接将效果图贴过来了<br><img src=\"../images/策略模式/商场收银系统效果图.jpg\" alt=\"商场收银系统效果图\"><br>不难写出下面的伪代码</p>\n<h1 id=\"1-0\"><a href=\"#1-0\" class=\"headerlink\" title=\"1.0\"></a>1.0</h1><pre><code class=\"lang-java\">总计=0;\n计算总费用()&#123;\n   单次费用=单价*数量\n    总计累加单次费用\n    将此次商品加入显示结果集合中，格式:单价:xxxx 数量: xxxx 合计:xxxx\n    在界面上显示总计费用\n&#125;\n</code></pre>\n<h1 id=\"1-1-增加打折\"><a href=\"#1-1-增加打折\" class=\"headerlink\" title=\"1.1 增加打折\"></a>1.1 增加打折</h1><p>改,将打折直接加入到下拉列表中，根据当前下拉列表选中的项来计算总费用,伪代码如下</p>\n<pre><code class=\"lang-java\">    页面初始化方法()&#123;\n        将折扣力度加入到下拉列表中\n        折扣力度分别是正常收费，7折，6折，索引依次是0,1,2\n    &#125;\n    总计=0;\n    计算总费用()&#123;\n        单次费用 = 单价*数量\n        对当前下拉列表中选中的项做判断，根据索引对单次费用进行操作\n        下面的代码和1.0版本一致\n    &#125;\n</code></pre>\n<p>但是忽略了一个问题，是在商场使用，而商场的活动有一个特点：持续时间短，改变大。若是以上面的方式实现的话，如果商场搞出了一个满多少返多少或满多少积分减多少的活动呢？<br>商场常见的活动如下:</p>\n<ol>\n<li>满xxx返xxx</li>\n<li>打xxx折</li>\n</ol>\n<p>这样的话关于打折的只用写一个类即可,初始化时传入打几折即可<br>书中的原文让我茅塞顿开</p>\n<blockquote>\n<p><b>面向对象的编程,并不是类越多越好,类的划分是为了封装，但分类的基础是抽象,具有相同属性和功能的对象的抽象集合才是类<b></p>\n</blockquote>\n<p>所有的活动抽象成CashSuper,满xx返xx,打xx折全部继承自CashSuper<br><img src=\"../images/策略模式/FactoryAttempt.jpg\" alt=\"\"></p>\n<h1 id=\"融入简单工厂\"><a href=\"#融入简单工厂\" class=\"headerlink\" title=\"融入简单工厂\"></a>融入简单工厂</h1><pre><code class=\"lang-java\">package test;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Write &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.print(&quot;请输入总计费用:&quot;);\n        double fees = s.nextDouble();\n        System.out.println(&quot;当前活动 0:正常收费 1:7折 2:6折 3:满300减100\\n请输入你选择的活动编号&quot;);\n        int idx = s.nextInt();\n        CashSuper cs = CashFactory.createCashSuper(fees,idx);\n        System.out.print(&quot;总费用是:&quot;);\n        System.out.println(cs.acceptMoney());\n    &#125;\n&#125;\nclass CashFactory&#123;\n    //idx是选择的活动\n    //0:正常收费 1:7折 2:6折 3:满300减100\n    public static CashContext createCashSuper(double money,int idx)&#123;\n        CashContext cc = null;\n        switch (idx)&#123;\n            case 0:\n                cs = new CashContext(new CashNormal(money));\n                break;\n            case 1:\n            case 2:\n                //这里最好分开写\n                cs = new CashContext(new CashDiscount(money,idx==1?0.7:0.6));\n                break;\n            case 3:\n                cs = new CashContext(new CashReturn(money,300,100));\n                break;\n        &#125;\n        return cs;\n    &#125;\n&#125;\nabstract class CashSuper&#123;\n    protected double money;\n    public CashSuper(double money)&#123;\n        this.money = money;\n    &#125;\n    public abstract double acceptMoney();\n&#125;\nclass CashDiscount extends CashSuper&#123;\n\n    private double discount;\n    public CashDiscount(double money,double discount) &#123;\n        super(money);\n        this.discount=discount;\n    &#125;\n\n    @Override\n    public double acceptMoney() &#123;\n        //不打折discount就是1,把这个不打折的抽象成一个类，让每个类的职责单一化\n        return money*discount;\n    &#125;\n&#125;\nclass CashNormal extends  CashSuper&#123;\n\n    public CashNormal(double money) &#123;\n        super(money);\n    &#125;\n\n    @Override\n    public double acceptMoney() &#123;\n        return money;\n    &#125;\n&#125;\nclass CashReturn extends CashSuper&#123;\n    private double condition;//条件\n    private double returnMoney;//返利\n    public CashReturn(double money,double condition,double returnMoney)&#123;\n        super(money);\n        this.condition = condition;\n        this.returnMoney = returnMoney;\n    &#125;\n\n    @Override\n    public double acceptMoney() &#123;\n        return this.money - Math.floor(this.money/this.condition)*this.returnMoney;\n    &#125;\n&#125;\n</code></pre>\n<p>不足之处:</p>\n<ul>\n<li>数据校验没写</li>\n<li>如果要增加打5折和打9折的活动，这里有一个想法，根据字符串判断是那种活动，若是打折活动，将折扣截取出来，这样就不用写重复的代码了</li>\n<li>如果要增加满多少积分换取奖品呢</li>\n<li>如果商场要把满300减100改成满300减50呢？又要改代码，麻烦</li>\n</ul>\n<p>接下来上策略模式</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><blockquote>\n<p>定义: 策略模式(Strategy),它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户<br>就这个例子而言，算法就是每一种活动的对钱的操作</p>\n<h2 id=\"整体结构图\"><a href=\"#整体结构图\" class=\"headerlink\" title=\"整体结构图\"></a>整体结构图</h2><p><img src=\"../images/策略模式/StrategyPattern.jpg\" alt=\"\"></p>\n</blockquote>\n<p>简易策略模式</p>\n<pre><code class=\"lang-java\">class Context&#123;\n    Strategy s = null;\n    public Context(Strategy s)&#123;\n        this.s = s;\n    &#125;\n    public void ContextMethod()&#123;\n        s.AlgorithmMethod();\n    &#125;\n&#125;\nabstract class Strategy&#123;\n    //抽象算法方法\n    public abstract void AlgorithmMethod();\n&#125;\nclass ConcreteA extends Strategy&#123;\n\n    @Override\n    public void AlgorithmMethod() &#123;\n        System.out.println(&quot;算法A实现&quot;);\n    &#125;\n&#125;\nclass ConcreteB extends Strategy&#123;\n\n    @Override\n    public void AlgorithmMethod() &#123;\n        System.out.println(&quot;算法B实现&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>基于策略模式对基于简单工厂的进行改造，加一个CashContext类，改写客户端的方法，Strategy对应到这个例子就是基于简单工厂的CashSuper类。<br>CashContext类</p>\n<pre><code class=\"lang-java\">class CashContext&#123;\n    CashSuper cs;\n    public CashContext(int idx,double money)&#123;\n       switch (idx)&#123;\n            case 0:\n                cs = new CashContext(new CashNormal(money));\n                break;\n            case 1:\n            case 2:\n                //这里最好分开写\n                cs = new CashContext(new CashDiscount(money,idx==1?0.7:0.6));\n                break;\n            case 3:\n                cs = new CashContext(new CashReturn(money,300,100));\n                break;\n        &#125;\n    &#125;\n    public void ContextMethod()&#123;\n        cs.acceptMoney();\n    &#125;\n&#125;\n</code></pre>\n<p>客户端</p>\n<pre><code class=\"lang-java\">        CashContext cc = new CashContext(idx,fees)\n        System.out.println(cc.acceptMoney());\n</code></pre>\n<p>搞定</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>策略模式可以以相同的方式调用所有的算法，降低了各种算法类之间的耦合。能理解前面半句话从客户端的<code>cc.acceptMoney()</code>可以看出来，都是调用一个acceptMoney，降低各种算法之间的耦合有点感触，可能是算法之间没有彼此依赖，这样改变一个算法其他的算法不受影响</li>\n<li>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。就这个例子而言这里的公共功能就是计算钱的功能，如果把属性算上的话，那么抽象类CashSuper的money属性也算一个。</li>\n<li>策略模式简化了单元测试。这个理解不了，单元测试用过，但是没什么感触</li>\n<li>针对于if语句中堆砌了大量的操作的情况，把这些大量的操作封装成一个个Strategy类，这样利用策略模式的特点之一：以相同的方式调用所有的算法，这样可以消除语句</li>\n</ol>\n<h2 id=\"面向对象的理解\"><a href=\"#面向对象的理解\" class=\"headerlink\" title=\"面向对象的理解\"></a>面向对象的理解</h2><blockquote>\n<p>类的划分是为了封装，但划分的前提是抽象,具有相同属性和功能的对象的抽象集合才是类<b><br>继承，将共同属性和行为丢到父类中，这样减少代码冗余</p>\n</blockquote>\n<p>搞定</p>\n","text":" 是记录看《大话设计模式》这本书的感受 还是从一个想法开始入手，书中的是让我们写一个商场收银系统，由于我java没有学GUI的那部分，我就直接将效果图贴过来了不...","permalink":"/post/策略模式","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-0\"><span class=\"toc-text\">1.0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-1-%E5%A2%9E%E5%8A%A0%E6%89%93%E6%8A%98\"><span class=\"toc-text\">1.1 增加打折</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%9E%8D%E5%85%A5%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">融入简单工厂</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">策略模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">整体结构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">面向对象的理解</span></a></li></ol></li></ol>","author":{"name":"矽","slug":"blog-author","avatar":"https://ik.imagekit.io/bennyxguo/ObsidianestLogo-hex_hecqbw.png?updatedAt=1692679397324","link":"/","description":"","socials":{"github":"https://github.com/notdy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45418837","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibli.jpg","link":"https://space.bilibili.com/441747654"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"筛质数","uid":"183beebca0c6bcbcb988690a51b52267","slug":"筛质数","date":"2023-12-12T11:38:34.000Z","updated":"2023-12-17T07:43:37.430Z","comments":true,"path":"api/articles/筛质数.json","keywords":null,"cover":null,"text":"题目给定一个正整数 n，请你求出 1∼n 中质数的个数。 输入格式共一行，包含整数 n。 输出格式共一行，包含一个整数，表示 1∼n 中质数的个数。 数据范围 ...","permalink":"/post/筛质数","photos":[],"count_time":{"symbolsCount":880,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":7,"path":"api/tags/Algorithm.json"},{"name":"数论","slug":"数论","count":4,"path":"api/tags/数论.json"}],"author":{"name":"矽","slug":"blog-author","avatar":"https://ik.imagekit.io/bennyxguo/ObsidianestLogo-hex_hecqbw.png?updatedAt=1692679397324","link":"/","description":"","socials":{"github":"https://github.com/notdy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45418837","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibli.jpg","link":"https://space.bilibili.com/441747654"}}}}},"next_post":{"title":"快速排序","uid":"9c04d15496da1d73edddda137155e866","slug":"快速排序","date":"2023-12-11T10:26:01.000Z","updated":"2023-12-11T10:33:41.915Z","comments":true,"path":"api/articles/快速排序.json","keywords":null,"cover":null,"text":" 记录一下过程 import java.io.BufferedReader; import java.io.IOException; import java.i...","permalink":"/post/快速排序","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":7,"path":"api/tags/Algorithm.json"}],"author":{"name":"矽","slug":"blog-author","avatar":"https://ik.imagekit.io/bennyxguo/ObsidianestLogo-hex_hecqbw.png?updatedAt=1692679397324","link":"/","description":"","socials":{"github":"https://github.com/notdy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45418837","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibli.jpg","link":"https://space.bilibili.com/441747654"}}}}}}